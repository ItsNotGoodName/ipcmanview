// Package main generates bus based on all structs in a file.
package main

import (
	"os"
	"path"
	"regexp"
	"text/template"
)

type TemplateData struct {
	By      string
	Package string
	Imports []string
	Events  []string
}

const rawTemplate = `// Code generated by {{ .By }}; DO NOT EDIT.
package {{ .Package }}

import (
{{- range .Imports }}
	"{{.}}"
{{- end }}
)

func busLogError(name string, err error) {
	if err != nil {
		log.Err(err).Str("package", "{{ .Package }}").Str("name", name).Send()
	}
}

func NewBus(ctx context.Context) *Bus {
	return &Bus{
		ctx: ctx,
	}
}

type Bus struct {
	ctx context.Context
{{- range .Events }}
	on{{.}} []func(ctx context.Context, event {{ . }}) error
	names{{.}} []string
{{- end }}
}

func (b *Bus) Register(pub *pubsub.Pub) (*Bus) {
{{- range .Events }}
	b.On{{ . }}("pubsub", func(ctx context.Context, evt {{ . }}) error {
		err := pub.Broadcast(ctx, evt)
		if err == nil {
			return nil
		}
		return err
	})
{{- end }}
	return b
}

{{ range .Events }}
func (b *Bus) On{{ . }}(name string, h func(ctx context.Context, evt {{ . }}) error) {
	b.on{{ . }} = append(b.on{{ . }}, h)
	b.names{{ . }} = append(b.names{{ . }}, name)
}
{{ end }}

{{ range .Events }}
func (b *Bus) {{ . }}(evt {{ . }}) {
	for i, v := range b.on{{ . }} {
		busLogError(b.names{{ . }}[i],v(b.ctx, evt))
	}
}
{{ end }}
`

type Args struct {
	InputFilePath string
}

func ParseArgs() Args {
	return Args{
		InputFilePath: path.Clean(os.Args[1]),
	}
}

func main() {
	args := ParseArgs()
	outputFilePath := path.Join(path.Dir(args.InputFilePath), "bus.gen.go")

	_ = os.Remove(outputFilePath)

	must(must2(template.
		New("").
		Parse(rawTemplate)).
		Execute(must2(os.OpenFile(outputFilePath, os.O_CREATE|os.O_WRONLY, 0644)), TemplateData{
			By:      "generate-bus.go",
			Package: "event",
			Imports: []string{
				"context",
				"github.com/ItsNotGoodName/ipcmanview/pkg/pubsub",
				"github.com/rs/zerolog/log",
			},
			Events: events(args.InputFilePath),
		}))
}

func events(filePath string) []string {
	var events []string
	for _, v := range must2(regexp.Compile(`type (.*?) struct {`)).FindAllStringSubmatch(string(must2(os.ReadFile(filePath))), -1) {
		events = append(events, v[1])
	}
	return events
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func must2[T any](d T, err error) T {
	if err != nil {
		panic(err)
	}
	return d
}
