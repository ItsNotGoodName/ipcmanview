// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: auth.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/ItsNotGoodName/ipcmanview/internal/types"
)

const authCountGroup = `-- name: AuthCountGroup :one
SELECT
  count(*)
FROM
  groups
`

func (q *Queries) AuthCountGroup(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, authCountGroup)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const authCreateGroup = `-- name: AuthCreateGroup :one
INSERT INTO
  groups (name, description, created_at, updated_at)
VALUES
  (?, ?, ?, ?) RETURNING id
`

type AuthCreateGroupParams struct {
	Name        string
	Description string
	CreatedAt   types.Time
	UpdatedAt   types.Time
}

func (q *Queries) AuthCreateGroup(ctx context.Context, arg AuthCreateGroupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authCreateGroup,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const authCreateUser = `-- name: AuthCreateUser :one
INSERT INTO
  users (
    email,
    username,
    password,
    created_at,
    updated_at,
    disabled_at
  )
VALUES
  (?, ?, ?, ?, ?, ?) RETURNING id
`

type AuthCreateUserParams struct {
	Email      string
	Username   string
	Password   string
	CreatedAt  types.Time
	UpdatedAt  types.Time
	DisabledAt types.NullTime
}

func (q *Queries) AuthCreateUser(ctx context.Context, arg AuthCreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authCreateUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DisabledAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const authCreateUserSession = `-- name: AuthCreateUserSession :exec
INSERT INTO
  user_sessions (
    user_id,
    session,
    user_agent,
    ip,
    last_ip,
    last_used_at,
    created_at,
    expired_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type AuthCreateUserSessionParams struct {
	UserID     int64
	Session    string
	UserAgent  string
	Ip         string
	LastIp     string
	LastUsedAt types.Time
	CreatedAt  types.Time
	ExpiredAt  types.Time
}

func (q *Queries) AuthCreateUserSession(ctx context.Context, arg AuthCreateUserSessionParams) error {
	_, err := q.db.ExecContext(ctx, authCreateUserSession,
		arg.UserID,
		arg.Session,
		arg.UserAgent,
		arg.Ip,
		arg.LastIp,
		arg.LastUsedAt,
		arg.CreatedAt,
		arg.ExpiredAt,
	)
	return err
}

const authDeleteAdmin = `-- name: AuthDeleteAdmin :exec
DELETE FROM admins
WHERE
  user_id = ?
`

func (q *Queries) AuthDeleteAdmin(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, authDeleteAdmin, userID)
	return err
}

const authDeleteGroup = `-- name: AuthDeleteGroup :exec
DELETE FROM groups
WHERE
  id = ?
`

func (q *Queries) AuthDeleteGroup(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, authDeleteGroup, id)
	return err
}

const authDeleteUserSessionByExpired = `-- name: AuthDeleteUserSessionByExpired :exec
DELETE FROM user_sessions
WHERE
  expired_at < ?
`

func (q *Queries) AuthDeleteUserSessionByExpired(ctx context.Context, expiredAt types.Time) error {
	_, err := q.db.ExecContext(ctx, authDeleteUserSessionByExpired, expiredAt)
	return err
}

const authDeleteUserSessionBySession = `-- name: AuthDeleteUserSessionBySession :one
DELETE FROM user_sessions
WHERE
  session = ? RETURNING user_id
`

func (q *Queries) AuthDeleteUserSessionBySession(ctx context.Context, session string) (int64, error) {
	row := q.db.QueryRowContext(ctx, authDeleteUserSessionBySession, session)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const authDeleteUserSessionForUser = `-- name: AuthDeleteUserSessionForUser :exec
DELETE FROM user_sessions
WHERE
  id = ?
  AND user_id = ?
`

type AuthDeleteUserSessionForUserParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) AuthDeleteUserSessionForUser(ctx context.Context, arg AuthDeleteUserSessionForUserParams) error {
	_, err := q.db.ExecContext(ctx, authDeleteUserSessionForUser, arg.ID, arg.UserID)
	return err
}

const authDeleteUserSessionForUserAndNotSession = `-- name: AuthDeleteUserSessionForUserAndNotSession :exec
DELETE FROM user_sessions
WHERE
  user_id = ?
  AND id != ?
`

type AuthDeleteUserSessionForUserAndNotSessionParams struct {
	UserID int64
	ID     int64
}

func (q *Queries) AuthDeleteUserSessionForUserAndNotSession(ctx context.Context, arg AuthDeleteUserSessionForUserAndNotSessionParams) error {
	_, err := q.db.ExecContext(ctx, authDeleteUserSessionForUserAndNotSession, arg.UserID, arg.ID)
	return err
}

const authGetGroup = `-- name: AuthGetGroup :one
SELECT
  id, name, description, created_at, updated_at, disabled_at
FROM
  groups
where
  id = ?
`

func (q *Queries) AuthGetGroup(ctx context.Context, id int64) (Group, error) {
	row := q.db.QueryRowContext(ctx, authGetGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
	)
	return i, err
}

const authGetUser = `-- name: AuthGetUser :one
SELECT
  id, email, username, password, created_at, updated_at, disabled_at
FROM
  users
WHERE
  id = ?
`

func (q *Queries) AuthGetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, authGetUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
	)
	return i, err
}

const authGetUserByUsernameOrEmail = `-- name: AuthGetUserByUsernameOrEmail :one
SELECT
  id, email, username, password, created_at, updated_at, disabled_at
FROM
  users
WHERE
  username = ?1
  OR email = ?1
`

func (q *Queries) AuthGetUserByUsernameOrEmail(ctx context.Context, usernameOrEmail string) (User, error) {
	row := q.db.QueryRowContext(ctx, authGetUserByUsernameOrEmail, usernameOrEmail)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
	)
	return i, err
}

const authGetUserSessionForContext = `-- name: AuthGetUserSessionForContext :one
SELECT
  user_sessions.id as id,
  user_sessions.user_id as user_id,
  users.username,
  admins.user_id IS NOT NULL as 'admin',
  user_sessions.last_ip,
  user_sessions.last_used_at,
  users.disabled_at AS 'users_disabled_at',
  user_sessions.session
FROM
  user_sessions
  LEFT JOIN users ON users.id = user_sessions.user_id
  LEFT JOIN admins ON admins.user_id = user_sessions.user_id
WHERE
  session = ?
  AND expired_at > ?2
`

type AuthGetUserSessionForContextParams struct {
	Session string
	Now     types.Time
}

type AuthGetUserSessionForContextRow struct {
	ID              int64
	UserID          int64
	Username        sql.NullString
	Admin           bool
	LastIp          string
	LastUsedAt      types.Time
	UsersDisabledAt types.NullTime
	Session         string
}

func (q *Queries) AuthGetUserSessionForContext(ctx context.Context, arg AuthGetUserSessionForContextParams) (AuthGetUserSessionForContextRow, error) {
	row := q.db.QueryRowContext(ctx, authGetUserSessionForContext, arg.Session, arg.Now)
	var i AuthGetUserSessionForContextRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Admin,
		&i.LastIp,
		&i.LastUsedAt,
		&i.UsersDisabledAt,
		&i.Session,
	)
	return i, err
}

const authListGroupsForUser = `-- name: AuthListGroupsForUser :many
SELECT
  g.id, g.name, g.description, g.created_at, g.updated_at, g.disabled_at,
  gu.created_at AS joined_at
FROM
  groups AS g
  LEFT JOIN group_users AS gu ON gu.group_id = g.id
WHERE
  gu.user_id = ?
`

type AuthListGroupsForUserRow struct {
	ID          int64
	Name        string
	Description string
	CreatedAt   types.Time
	UpdatedAt   types.Time
	DisabledAt  types.NullTime
	JoinedAt    sql.NullTime
}

func (q *Queries) AuthListGroupsForUser(ctx context.Context, userID int64) ([]AuthListGroupsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, authListGroupsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthListGroupsForUserRow
	for rows.Next() {
		var i AuthListGroupsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authListUserSessionsForUserAndNotExpired = `-- name: AuthListUserSessionsForUserAndNotExpired :many
SELECT
  id, user_id, session, user_agent, ip, last_ip, last_used_at, created_at, expired_at
FROM
  user_sessions
WHERE
  user_id = ?
  AND expired_at > ?2
`

type AuthListUserSessionsForUserAndNotExpiredParams struct {
	UserID int64
	Now    types.Time
}

func (q *Queries) AuthListUserSessionsForUserAndNotExpired(ctx context.Context, arg AuthListUserSessionsForUserAndNotExpiredParams) ([]UserSession, error) {
	rows, err := q.db.QueryContext(ctx, authListUserSessionsForUserAndNotExpired, arg.UserID, arg.Now)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Session,
			&i.UserAgent,
			&i.Ip,
			&i.LastIp,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.ExpiredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authListUsersByGroup = `-- name: AuthListUsersByGroup :many
SELECT
  users.id, users.email, users.username, users.password, users.created_at, users.updated_at, users.disabled_at
FROM
  users
  LEFT JOIN group_users ON group_users.user_id = id
WHERE
  group_users.group_id = ?
`

func (q *Queries) AuthListUsersByGroup(ctx context.Context, groupID int64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, authListUsersByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authPatchUser = `-- name: AuthPatchUser :one
UPDATE users
SET
  username = coalesce(?1, username),
  email = coalesce(?2, email),
  password = coalesce(?3, password),
  updated_at = ?4
WHERE
  id = ?5 RETURNING id
`

type AuthPatchUserParams struct {
	Username  sql.NullString
	Email     sql.NullString
	Password  sql.NullString
	UpdatedAt types.Time
	ID        int64
}

func (q *Queries) AuthPatchUser(ctx context.Context, arg AuthPatchUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authPatchUser,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.UpdatedAt,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const authUpdateGroup = `-- name: AuthUpdateGroup :one
UPDATE groups
SET
  name = ?,
  description = ?,
  updated_at = ?
WHERE
  id = ? RETURNING id
`

type AuthUpdateGroupParams struct {
	Name        string
	Description string
	UpdatedAt   types.Time
	ID          int64
}

func (q *Queries) AuthUpdateGroup(ctx context.Context, arg AuthUpdateGroupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authUpdateGroup,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const authUpdateGroupDisabledAt = `-- name: AuthUpdateGroupDisabledAt :one
UPDATE groups
SET
  disabled_at = ?
WHERE
  id = ? RETURNING id
`

type AuthUpdateGroupDisabledAtParams struct {
	DisabledAt types.NullTime
	ID         int64
}

func (q *Queries) AuthUpdateGroupDisabledAt(ctx context.Context, arg AuthUpdateGroupDisabledAtParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authUpdateGroupDisabledAt, arg.DisabledAt, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const authUpdateUserDisabledAt = `-- name: AuthUpdateUserDisabledAt :one
UPDATE users
SET
  disabled_at = ?
WHERE
  id = ? RETURNING id
`

type AuthUpdateUserDisabledAtParams struct {
	DisabledAt types.NullTime
	ID         int64
}

func (q *Queries) AuthUpdateUserDisabledAt(ctx context.Context, arg AuthUpdateUserDisabledAtParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authUpdateUserDisabledAt, arg.DisabledAt, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const authUpdateUserSession = `-- name: AuthUpdateUserSession :exec
UPDATE user_sessions
SET
  last_ip = ?,
  last_used_at = ?
WHERE
  id = ?
`

type AuthUpdateUserSessionParams struct {
	LastIp     string
	LastUsedAt types.Time
	ID         int64
}

func (q *Queries) AuthUpdateUserSession(ctx context.Context, arg AuthUpdateUserSessionParams) error {
	_, err := q.db.ExecContext(ctx, authUpdateUserSession, arg.LastIp, arg.LastUsedAt, arg.ID)
	return err
}

const authUpsertAdmin = `-- name: AuthUpsertAdmin :one
INSERT OR IGNORE INTO
  admins (user_id, created_at)
VALUES
  (?, ?) RETURNING user_id
`

type AuthUpsertAdminParams struct {
	UserID    int64
	CreatedAt types.Time
}

func (q *Queries) AuthUpsertAdmin(ctx context.Context, arg AuthUpsertAdminParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authUpsertAdmin, arg.UserID, arg.CreatedAt)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE
  id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}
