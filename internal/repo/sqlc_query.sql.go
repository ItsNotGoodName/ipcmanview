// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: sqlc_query.sql

package repo

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"

	"github.com/ItsNotGoodName/ipcmanview/internal/types"
)

const createDahuaEvent = `-- name: CreateDahuaEvent :execlastid
INSERT INTO dahua_events (
  camera_id,
  code,
  action,
  ` + "`" + `index` + "`" + `,
  data,
  created_at
) VALUES (
  ?, ?, ?, ?, ?, ?
)
`

type CreateDahuaEventParams struct {
	CameraID  int64
	Code      string
	Action    string
	Index     int64
	Data      json.RawMessage
	CreatedAt types.Time
}

func (q *Queries) CreateDahuaEvent(ctx context.Context, arg CreateDahuaEventParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createDahuaEvent,
		arg.CameraID,
		arg.Code,
		arg.Action,
		arg.Index,
		arg.Data,
		arg.CreatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createDahuaEventDefaultRule = `-- name: CreateDahuaEventDefaultRule :exec
INSERT INTO dahua_event_default_rules(
  code,
  ignore_db,
  ignore_live,
  ignore_mqtt
) VALUES(
  ?,
  ?,
  ?,
  ?
)
`

type CreateDahuaEventDefaultRuleParams struct {
	Code       string
	IgnoreDb   bool
	IgnoreLive bool
	IgnoreMqtt bool
}

func (q *Queries) CreateDahuaEventDefaultRule(ctx context.Context, arg CreateDahuaEventDefaultRuleParams) error {
	_, err := q.db.ExecContext(ctx, createDahuaEventDefaultRule,
		arg.Code,
		arg.IgnoreDb,
		arg.IgnoreLive,
		arg.IgnoreMqtt,
	)
	return err
}

const createDahuaFile = `-- name: CreateDahuaFile :execlastid
INSERT INTO dahua_files (
  camera_id,
  channel,
  start_time,
  end_time,
  length,
  type,
  file_path,
  duration,
  disk,
  video_stream,
  flags,
  events,
  cluster,
  partition,
  pic_index,
  repeat,
  work_dir,
  work_dir_sn,
  updated_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? 
)
`

type CreateDahuaFileParams struct {
	CameraID    int64
	Channel     int64
	StartTime   types.Time
	EndTime     types.Time
	Length      int64
	Type        string
	FilePath    string
	Duration    int64
	Disk        int64
	VideoStream string
	Flags       types.StringSlice
	Events      types.StringSlice
	Cluster     int64
	Partition   int64
	PicIndex    int64
	Repeat      int64
	WorkDir     string
	WorkDirSn   int64
	UpdatedAt   types.Time
}

func (q *Queries) CreateDahuaFile(ctx context.Context, arg CreateDahuaFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createDahuaFile,
		arg.CameraID,
		arg.Channel,
		arg.StartTime,
		arg.EndTime,
		arg.Length,
		arg.Type,
		arg.FilePath,
		arg.Duration,
		arg.Disk,
		arg.VideoStream,
		arg.Flags,
		arg.Events,
		arg.Cluster,
		arg.Partition,
		arg.PicIndex,
		arg.Repeat,
		arg.WorkDir,
		arg.WorkDirSn,
		arg.UpdatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createDahuaFileScanLock = `-- name: CreateDahuaFileScanLock :one
INSERT INTO dahua_file_scan_locks (
  camera_id, created_at
) VALUES (
  ?, ?
) RETURNING camera_id, created_at
`

type CreateDahuaFileScanLockParams struct {
	CameraID  int64
	CreatedAt types.Time
}

func (q *Queries) CreateDahuaFileScanLock(ctx context.Context, arg CreateDahuaFileScanLockParams) (DahuaFileScanLock, error) {
	row := q.db.QueryRowContext(ctx, createDahuaFileScanLock, arg.CameraID, arg.CreatedAt)
	var i DahuaFileScanLock
	err := row.Scan(&i.CameraID, &i.CreatedAt)
	return i, err
}

const deleteDahuaCamera = `-- name: DeleteDahuaCamera :exec
DELETE FROM dahua_cameras WHERE id = ?
`

func (q *Queries) DeleteDahuaCamera(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaCamera, id)
	return err
}

const deleteDahuaEventDefaultRule = `-- name: DeleteDahuaEventDefaultRule :exec
DELETE FROM dahua_event_default_rules WHERE id = ?
`

func (q *Queries) DeleteDahuaEventDefaultRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaEventDefaultRule, id)
	return err
}

const deleteDahuaFile = `-- name: DeleteDahuaFile :exec
DELETE FROM dahua_files
WHERE
  updated_at < ?1 AND
  camera_id = ?2 AND
  start_time <= ?3 AND
  ?4 < start_time
`

type DeleteDahuaFileParams struct {
	UpdatedAt types.Time
	CameraID  int64
	End       types.Time
	Start     types.Time
}

func (q *Queries) DeleteDahuaFile(ctx context.Context, arg DeleteDahuaFileParams) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaFile,
		arg.UpdatedAt,
		arg.CameraID,
		arg.End,
		arg.Start,
	)
	return err
}

const deleteDahuaFileScanLock = `-- name: DeleteDahuaFileScanLock :exec
DELETE FROM dahua_file_scan_locks WHERE camera_id = ?
`

func (q *Queries) DeleteDahuaFileScanLock(ctx context.Context, cameraID int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaFileScanLock, cameraID)
	return err
}

const getDahuaCamera = `-- name: GetDahuaCamera :one
SELECT dahua_cameras.id, dahua_cameras.name, dahua_cameras.address, dahua_cameras.username, dahua_cameras.password, dahua_cameras.location, dahua_cameras.created_at, dahua_cameras.updated_at, coalesce(seed, id) FROM dahua_cameras 
LEFT JOIN dahua_seeds ON dahua_seeds.camera_id = dahua_cameras.id
WHERE id = ? LIMIT 1
`

type GetDahuaCameraRow struct {
	ID        int64
	Name      string
	Address   string
	Username  string
	Password  string
	Location  types.Location
	CreatedAt types.Time
	UpdatedAt types.Time
	Seed      int64
}

func (q *Queries) GetDahuaCamera(ctx context.Context, id int64) (GetDahuaCameraRow, error) {
	row := q.db.QueryRowContext(ctx, getDahuaCamera, id)
	var i GetDahuaCameraRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Username,
		&i.Password,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Seed,
	)
	return i, err
}

const getDahuaEventData = `-- name: GetDahuaEventData :one
SELECT data FROM dahua_events WHERE id = ?
`

func (q *Queries) GetDahuaEventData(ctx context.Context, id int64) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getDahuaEventData, id)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getDahuaEventDefaultRule = `-- name: GetDahuaEventDefaultRule :one
SELECT id, code, ignore_db, ignore_live, ignore_mqtt FROM dahua_event_default_rules
WHERE id = ?
`

func (q *Queries) GetDahuaEventDefaultRule(ctx context.Context, id int64) (DahuaEventDefaultRule, error) {
	row := q.db.QueryRowContext(ctx, getDahuaEventDefaultRule, id)
	var i DahuaEventDefaultRule
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.IgnoreDb,
		&i.IgnoreLive,
		&i.IgnoreMqtt,
	)
	return i, err
}

const getDahuaFileByFilePath = `-- name: GetDahuaFileByFilePath :one
SELECT id, camera_id, channel, start_time, end_time, length, type, file_path, duration, disk, video_stream, flags, events, cluster, "partition", pic_index, repeat, work_dir, work_dir_sn, updated_at
FROM dahua_files
WHERE camera_id = ? and file_path = ?
`

type GetDahuaFileByFilePathParams struct {
	CameraID int64
	FilePath string
}

func (q *Queries) GetDahuaFileByFilePath(ctx context.Context, arg GetDahuaFileByFilePathParams) (DahuaFile, error) {
	row := q.db.QueryRowContext(ctx, getDahuaFileByFilePath, arg.CameraID, arg.FilePath)
	var i DahuaFile
	err := row.Scan(
		&i.ID,
		&i.CameraID,
		&i.Channel,
		&i.StartTime,
		&i.EndTime,
		&i.Length,
		&i.Type,
		&i.FilePath,
		&i.Duration,
		&i.Disk,
		&i.VideoStream,
		&i.Flags,
		&i.Events,
		&i.Cluster,
		&i.Partition,
		&i.PicIndex,
		&i.Repeat,
		&i.WorkDir,
		&i.WorkDirSn,
		&i.UpdatedAt,
	)
	return i, err
}

const getDahuaFileCursor = `-- name: GetDahuaFileCursor :one
SELECT camera_id, quick_cursor, full_cursor, full_epoch, full_complete FROM dahua_file_cursors 
WHERE camera_id = ?
`

func (q *Queries) GetDahuaFileCursor(ctx context.Context, cameraID int64) (DahuaFileCursor, error) {
	row := q.db.QueryRowContext(ctx, getDahuaFileCursor, cameraID)
	var i DahuaFileCursor
	err := row.Scan(
		&i.CameraID,
		&i.QuickCursor,
		&i.FullCursor,
		&i.FullEpoch,
		&i.FullComplete,
	)
	return i, err
}

const getSettings = `-- name: GetSettings :one
SELECT site_name, default_location FROM settings
LIMIT 1
`

func (q *Queries) GetSettings(ctx context.Context) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettings)
	var i Setting
	err := row.Scan(&i.SiteName, &i.DefaultLocation)
	return i, err
}

const listDahuaCamera = `-- name: ListDahuaCamera :many
SELECT dahua_cameras.id, dahua_cameras.name, dahua_cameras.address, dahua_cameras.username, dahua_cameras.password, dahua_cameras.location, dahua_cameras.created_at, dahua_cameras.updated_at, coalesce(seed, id) FROM dahua_cameras 
LEFT JOIN dahua_seeds ON dahua_seeds.camera_id = dahua_cameras.id
`

type ListDahuaCameraRow struct {
	ID        int64
	Name      string
	Address   string
	Username  string
	Password  string
	Location  types.Location
	CreatedAt types.Time
	UpdatedAt types.Time
	Seed      int64
}

func (q *Queries) ListDahuaCamera(ctx context.Context) ([]ListDahuaCameraRow, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaCamera)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaCameraRow
	for rows.Next() {
		var i ListDahuaCameraRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Username,
			&i.Password,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Seed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaCameraByIDs = `-- name: ListDahuaCameraByIDs :many
SELECT dahua_cameras.id, dahua_cameras.name, dahua_cameras.address, dahua_cameras.username, dahua_cameras.password, dahua_cameras.location, dahua_cameras.created_at, dahua_cameras.updated_at, coalesce(seed, id) FROM dahua_cameras 
LEFT JOIN dahua_seeds ON dahua_seeds.camera_id = dahua_cameras.id
WHERE id IN (/*SLICE:ids*/?)
`

type ListDahuaCameraByIDsRow struct {
	ID        int64
	Name      string
	Address   string
	Username  string
	Password  string
	Location  types.Location
	CreatedAt types.Time
	UpdatedAt types.Time
	Seed      int64
}

func (q *Queries) ListDahuaCameraByIDs(ctx context.Context, ids []int64) ([]ListDahuaCameraByIDsRow, error) {
	query := listDahuaCameraByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaCameraByIDsRow
	for rows.Next() {
		var i ListDahuaCameraByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Username,
			&i.Password,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Seed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaEventActions = `-- name: ListDahuaEventActions :many
SELECT DISTINCT action FROM dahua_events
`

func (q *Queries) ListDahuaEventActions(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaEventActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var action string
		if err := rows.Scan(&action); err != nil {
			return nil, err
		}
		items = append(items, action)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaEventCodes = `-- name: ListDahuaEventCodes :many
SELECT DISTINCT code FROM dahua_events
`

func (q *Queries) ListDahuaEventCodes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaEventCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		items = append(items, code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaEventDefaultRule = `-- name: ListDahuaEventDefaultRule :many
SELECT id, code, ignore_db, ignore_live, ignore_mqtt FROM dahua_event_default_rules
`

func (q *Queries) ListDahuaEventDefaultRule(ctx context.Context) ([]DahuaEventDefaultRule, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaEventDefaultRule)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DahuaEventDefaultRule
	for rows.Next() {
		var i DahuaEventDefaultRule
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.IgnoreDb,
			&i.IgnoreLive,
			&i.IgnoreMqtt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaFileCursor = `-- name: ListDahuaFileCursor :many
SELECT 
  c.camera_id, c.quick_cursor, c.full_cursor, c.full_epoch, c.full_complete,
  count(f.camera_id) as files
FROM dahua_file_cursors AS c
LEFT JOIN dahua_files as f ON f.camera_id = c.camera_id
GROUP BY c.camera_id
`

type ListDahuaFileCursorRow struct {
	CameraID     int64
	QuickCursor  types.Time
	FullCursor   types.Time
	FullEpoch    types.Time
	FullComplete bool
	Files        int64
}

func (q *Queries) ListDahuaFileCursor(ctx context.Context) ([]ListDahuaFileCursorRow, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaFileCursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaFileCursorRow
	for rows.Next() {
		var i ListDahuaFileCursorRow
		if err := rows.Scan(
			&i.CameraID,
			&i.QuickCursor,
			&i.FullCursor,
			&i.FullEpoch,
			&i.FullComplete,
			&i.Files,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaFileTypes = `-- name: ListDahuaFileTypes :many
SELECT DISTINCT type
FROM dahua_files
`

func (q *Queries) ListDahuaFileTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaFileTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var type_ string
		if err := rows.Scan(&type_); err != nil {
			return nil, err
		}
		items = append(items, type_)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDahuaCamera = `-- name: UpdateDahuaCamera :execlastid
UPDATE dahua_cameras 
SET name = ?, address = ?, username = ?, password = ?, location = ?, updated_at = ?
WHERE id = ?
`

type UpdateDahuaCameraParams struct {
	Name      string
	Address   string
	Username  string
	Password  string
	Location  types.Location
	UpdatedAt types.Time
	ID        int64
}

func (q *Queries) UpdateDahuaCamera(ctx context.Context, arg UpdateDahuaCameraParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateDahuaCamera,
		arg.Name,
		arg.Address,
		arg.Username,
		arg.Password,
		arg.Location,
		arg.UpdatedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updateDahuaEventDefaultRule = `-- name: UpdateDahuaEventDefaultRule :exec
UPDATE dahua_event_default_rules 
SET 
  code = ?,
  ignore_db = ?,
  ignore_live = ?,
  ignore_mqtt = ?
WHERE id = ?
`

type UpdateDahuaEventDefaultRuleParams struct {
	Code       string
	IgnoreDb   bool
	IgnoreLive bool
	IgnoreMqtt bool
	ID         int64
}

func (q *Queries) UpdateDahuaEventDefaultRule(ctx context.Context, arg UpdateDahuaEventDefaultRuleParams) error {
	_, err := q.db.ExecContext(ctx, updateDahuaEventDefaultRule,
		arg.Code,
		arg.IgnoreDb,
		arg.IgnoreLive,
		arg.IgnoreMqtt,
		arg.ID,
	)
	return err
}

const updateDahuaFile = `-- name: UpdateDahuaFile :execlastid
UPDATE dahua_files 
SET 
  channel = ?,
  start_time = ?,
  end_time = ?,
  length = ?,
  type = ?,
  duration = ?,
  disk = ?,
  video_stream = ?,
  flags = ?,
  events = ?,
  cluster = ?,
  partition = ?,
  pic_index = ?,
  repeat = ?,
  work_dir = ?,
  work_dir_sn = ?,
  updated_at = ?
WHERE camera_id = ? AND file_path = ?
`

type UpdateDahuaFileParams struct {
	Channel     int64
	StartTime   types.Time
	EndTime     types.Time
	Length      int64
	Type        string
	Duration    int64
	Disk        int64
	VideoStream string
	Flags       types.StringSlice
	Events      types.StringSlice
	Cluster     int64
	Partition   int64
	PicIndex    int64
	Repeat      int64
	WorkDir     string
	WorkDirSn   int64
	UpdatedAt   types.Time
	CameraID    int64
	FilePath    string
}

func (q *Queries) UpdateDahuaFile(ctx context.Context, arg UpdateDahuaFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateDahuaFile,
		arg.Channel,
		arg.StartTime,
		arg.EndTime,
		arg.Length,
		arg.Type,
		arg.Duration,
		arg.Disk,
		arg.VideoStream,
		arg.Flags,
		arg.Events,
		arg.Cluster,
		arg.Partition,
		arg.PicIndex,
		arg.Repeat,
		arg.WorkDir,
		arg.WorkDirSn,
		arg.UpdatedAt,
		arg.CameraID,
		arg.FilePath,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updateDahuaFileCursor = `-- name: UpdateDahuaFileCursor :one
UPDATE dahua_file_cursors
SET 
  quick_cursor = ?,
  full_cursor = ?,
  full_epoch = ?
WHERE camera_id = ?
RETURNING camera_id, quick_cursor, full_cursor, full_epoch, full_complete
`

type UpdateDahuaFileCursorParams struct {
	QuickCursor types.Time
	FullCursor  types.Time
	FullEpoch   types.Time
	CameraID    int64
}

func (q *Queries) UpdateDahuaFileCursor(ctx context.Context, arg UpdateDahuaFileCursorParams) (DahuaFileCursor, error) {
	row := q.db.QueryRowContext(ctx, updateDahuaFileCursor,
		arg.QuickCursor,
		arg.FullCursor,
		arg.FullEpoch,
		arg.CameraID,
	)
	var i DahuaFileCursor
	err := row.Scan(
		&i.CameraID,
		&i.QuickCursor,
		&i.FullCursor,
		&i.FullEpoch,
		&i.FullComplete,
	)
	return i, err
}

const updateSettings = `-- name: UpdateSettings :one
UPDATE settings
SET
  default_location = coalesce(?1, default_location),
  site_name = coalesce(?2, site_name)
WHERE 1 = 1
RETURNING site_name, default_location
`

type UpdateSettingsParams struct {
	DefaultLocation types.Location
	SiteName        sql.NullString
}

func (q *Queries) UpdateSettings(ctx context.Context, arg UpdateSettingsParams) (Setting, error) {
	row := q.db.QueryRowContext(ctx, updateSettings, arg.DefaultLocation, arg.SiteName)
	var i Setting
	err := row.Scan(&i.SiteName, &i.DefaultLocation)
	return i, err
}

const allocateDahuaSeed = `-- name: allocateDahuaSeed :exec
UPDATE dahua_seeds 
SET camera_id = ?1
WHERE seed = (SELECT seed FROM dahua_seeds WHERE camera_id = ?1 OR camera_id IS NULL ORDER BY camera_id asc LIMIT 1)
`

func (q *Queries) allocateDahuaSeed(ctx context.Context, cameraID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, allocateDahuaSeed, cameraID)
	return err
}

const createDahuaCamera = `-- name: createDahuaCamera :execlastid
INSERT INTO dahua_cameras (
  name, address, username, password, location, created_at, updated_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
`

type createDahuaCameraParams struct {
	Name      string
	Address   string
	Username  string
	Password  string
	Location  types.Location
	CreatedAt types.Time
	UpdatedAt types.Time
}

func (q *Queries) createDahuaCamera(ctx context.Context, arg createDahuaCameraParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createDahuaCamera,
		arg.Name,
		arg.Address,
		arg.Username,
		arg.Password,
		arg.Location,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createDahuaFileCursor = `-- name: createDahuaFileCursor :exec
INSERT INTO dahua_file_cursors (
  camera_id,
  quick_cursor,
  full_cursor,
  full_epoch
) VALUES (
  ?, ?, ?, ?
)
`

type createDahuaFileCursorParams struct {
	CameraID    int64
	QuickCursor types.Time
	FullCursor  types.Time
	FullEpoch   types.Time
}

func (q *Queries) createDahuaFileCursor(ctx context.Context, arg createDahuaFileCursorParams) error {
	_, err := q.db.ExecContext(ctx, createDahuaFileCursor,
		arg.CameraID,
		arg.QuickCursor,
		arg.FullCursor,
		arg.FullEpoch,
	)
	return err
}

const getDahuaEventRule = `-- name: getDahuaEventRule :many
SELECT 
  ignore_db,
  ignore_live,
  ignore_mqtt
FROM dahua_event_rules 
WHERE camera_id = ?1 AND (dahua_event_rules.code = ?2 OR dahua_event_rules.code = '')
UNION ALL
SELECT 
  ignore_db,
  ignore_live,
  ignore_mqtt
FROM dahua_event_default_rules
WHERE dahua_event_default_rules.code = ?2 OR dahua_event_default_rules.code = ''
`

type getDahuaEventRuleParams struct {
	CameraID int64
	Code     string
}

type getDahuaEventRuleRow struct {
	IgnoreDb   bool
	IgnoreLive bool
	IgnoreMqtt bool
}

func (q *Queries) getDahuaEventRule(ctx context.Context, arg getDahuaEventRuleParams) ([]getDahuaEventRuleRow, error) {
	rows, err := q.db.QueryContext(ctx, getDahuaEventRule, arg.CameraID, arg.Code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getDahuaEventRuleRow
	for rows.Next() {
		var i getDahuaEventRuleRow
		if err := rows.Scan(&i.IgnoreDb, &i.IgnoreLive, &i.IgnoreMqtt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
